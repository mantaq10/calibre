# vim:fileencoding=utf-8
# License: GPL v3 Copyright: 2020, Kovid Goyal <kovid at kovidgoyal.net>
from __python__ import bound_methods, hash_literals

from elementmaker import E
from gettext import gettext as _

from book_list.globals import get_session_data
from book_list.theme import get_color
from dom import clear, svgicon
from read_book.globals import runtime, ui_operations
from read_book.highlights import HighlightStyle

ICON_SIZE = '3ex'


def position_bar_avoiding_handles(lh, rh, left, top, bar_width, bar_height, available_width, available_height, buffer):
    # adjust position to minimize overlap with handles

    def bar_rect(left, top):
        return {'left': left, 'top': top, 'right': left + bar_width, 'bottom': top + bar_height}

    def overlaps_a_handle(left, top):
        b = bar_rect(left, top)
        if elements_overlap(lh, b):
            return lh
        if elements_overlap(rh, b):
            return rh

    if not overlaps_a_handle(left, top):
        return

    if Math.abs(lh.top - rh.top) < lh.height + buffer:
        # handles close vertically, place either above or below
        bottom = max(lh.bottom, rh.bottom)
        has_space_below = bottom + bar_height < available_height - buffer
        if has_space_below:
            return {'top': bottom, 'put_below': True}
        return {'top': min(lh.top, rh.top), 'put_below': False}

    b = bar_rect(left, top)
    if lh.left > rh.left:
        lh, rh = rh, lh
    left_overlaps = elements_overlap(lh, b)
    right_overlaps = elements_overlap(rh, b)
    if not left_overlaps or not right_overlaps:
        # overlapping a single handle, see if we can move horizontally
        h = lh if left_overlaps else rh
        d1 = d2 = 2 * available_width
        q1 = h.left - bar_width - 1
        if q1 > -buffer and not overlaps_a_handle(q1, top):
            d1 = abs(left - q1)
        q2 = h.right + 1
        if q2 + bar_width < available_width + buffer and not overlaps_a_handle(q2, top):
            d2 = abs(left - q2)
        d = min(d1, d2)
        if d < available_width:
            return {'left': q1 if d is d1 else q2}

    # try to place either to left of both handles, between both handles, to
    # the right of both
    d1 = d2 = d3 = 2 * available_width
    q1 = lh.left - bar_width - 1
    if q1 > -buffer and not overlaps_a_handle(q1, top):
        d1 = abs(left - q1)
    q2 = lh.right + 1
    if q2 + bar_width < rh.left + buffer and not overlaps_a_handle(q2, top):
        d2 = abs(left - q2)
    q3 = rh.right + 1
    if q3 + bar_width < available_width + buffer and not overlaps_a_handle(q3, top):
        d3 = abs(left - q3)
    d = min(d1, d2, d3)
    if d < available_width:
        return {'left': q1 if d is d1 else (q2 if d is d2 else q3)}

    # look above both vertically, between both and below both
    th, bh = v'[lh, rh]' if lh.top <= rh.top else v'[rh, lh]'
    d1 = d2 = d3 = 2 * available_height
    q1 = th.top - bar_height - 1
    if q1 > -buffer and not overlaps_a_handle(left, q1):
        d1 = abs(top - q1)
    q2 = th.bottom + 1
    if q2 + bar_height < bh.top + buffer and not overlaps_a_handle(left, q2):
        d2 = abs(top - q2)
    q3 = bh.bottom + 1
    if q3 + bar_height < available_height + buffer and not overlaps_a_handle(left, q3):
        d3 = abs(top - q3)
    d = min(d1, d2, d3)
    if d < available_height:
        return {'top': (q1 + bar_height) if d is d1 else (q2 if d is d2 else q3), 'put_below': d is not d1}

    # look in the four corners
    if not overlaps_a_handle(buffer, buffer):
        return {'left': buffer, 'top': buffer + bar_height, 'put_below': False}
    if not overlaps_a_handle(available_width - bar_width, buffer):
        return {'left': available_width - bar_width, 'top': buffer + bar_height, 'put_below': False}
    if not overlaps_a_handle(buffer, available_height - bar_height):
        return {'left': buffer, 'top': available_height - bar_height, 'put_below': True}
    if not overlaps_a_handle(available_width - bar_width, available_height - bar_height):
        return {'left': available_width - bar_width, 'top': available_height - bar_height, 'put_below': True}

    # give up should be relatively rare



def quick_highlight_icon(name, tooltip, hcolor):
    svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
    svg.setAttribute('style', f'fill: currentColor; height: 2ex; width: 2ex; vertical-align: text-top; margin: 0')
    u = document.createElementNS('http://www.w3.org/2000/svg', 'use')
    svg.appendChild(u)
    svg.firstChild.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#icon-' + name)
    ans = E.div(
        style=f'width: {ICON_SIZE}; height: {ICON_SIZE}; display: flex; flex-direction: column',
        title=tooltip or '',
        svg,
        E.div(style=f'width: {ICON_SIZE}; height: 1ex; background-color: {hcolor}; color: {hcolor}; margin: 0', '.')
    )
    return ans


def all_actions():
    def a(icon, text, func, needs_highlight):
        return {
            'icon': icon, 'text': text, 'function_name': func, 'needs_highlight': v'!!needs_highlight',
            'icon_function': def (hcolor):
                return svgicon(icon, ICON_SIZE, ICON_SIZE, text)
    }

    if not all_actions.ans:
        all_actions.ans = {
            'copy': a('copy', _('Copy to clipboard'), 'copy_to_clipboard'),
            'lookup': a('library', _('Lookup/search selected word'), 'lookup'),
            'quick_highlight': a('highlight', _('Quick highlight in current color'), 'quick_highlight'),
            'highlight': a('highlight', _('Highlight selection in notes mode'), 'create_highlight'),
            'selection': a('arrows-h', _('Highlight adjusting selection'), 'adjust_selection'),
            'search_net': a('search', _('Search for selection on the net'), 'internet_search'),
            'remove_highlight': a('trash', _('Remove this highlight'), 'remove_highlight', True),
            'clear': a('close', _('Clear selection'), 'clear_selection'),
        }
        qh = all_actions.ans.quick_highlight
        qh.icon_function = quick_highlight_icon.bind(None, qh.icon, qh.text)
    return all_actions.ans


def selection_handle(is_left, bg, fg):
    ans = svgicon('selection-handle')
    use = ans.querySelector('use')
    use.style.stroke = fg
    use.style.fill = bg
    s = ans.style
    if not is_left:
        s.transform = 'scaleX(-1)'
    s.position = 'absolute'
    s.boxSizing = 'border-box'
    s.touchAction = 'none'
    s.pointerEvents = 'auto'
    return ans


def elements_overlap(a, b):
    return a.left < b.right and b.left < a.right and a.top < b.bottom and b.top < a.bottom


class SelectionBar:

    def __init__(self, view):
        self.view = view
        self.current_highlight_style = HighlightStyle(get_session_data().get('highlight_style'))

    def build_bar(self, annot_id):
        notes = self.view.annotations_manager.notes_for_highlight(annot_id)
        c = self.container
        max_width = 'min(50rem, 90vw)' if self.supports_css_min_max else '50rem'
        bar_container = E.div(
            style='position: absolute; border: solid 1px currentColor; border-radius: 5px;'
            'left: 0; top: 0; pointer-events: auto; display: flex; flex-direction: column;'
            'background-color: {}; max-width: {}'.format(get_color("window-background"), max_width),

            E.div(style='height: 4ex; display: flex; align-items: center; padding: 5px; justify-content: center'),

            E.hr(style='border-top: solid 1px; margin: 0; padding: 0; display: none'),

            E.div(
                style='display: none; padding: 5px;',
                E.div(),
            ),
        )
        bar = bar_container.firstChild
        handle_fill = get_color('window-background')
        left_handle = selection_handle(True, handle_fill, self.view.current_color_scheme.foreground)
        right_handle = selection_handle(False, handle_fill, self.view.current_color_scheme.foreground)
        c.appendChild(left_handle)
        c.appendChild(right_handle)
        c.appendChild(bar_container)
        hs = self.current_highlight_style.highlight_shade

        def cb(ac, callback):
            ans = ac.icon_function(hs)
            ans.addEventListener('click', def(ev):
                callback(ev)
                self.view.focus_iframe()
            )
            ans.classList.add('simple-link')
            ans.style.marginLeft = ans.style.marginRight = '0.5rem'
            return ans

        actions = all_actions()
        sd = get_session_data()
        for acname in sd.get('selection_bar_actions'):
            ac = actions[acname]
            if ac and (not ac.needs_highlight or v'!!annot_id'):
                bar.appendChild(cb(ac, self[ac.function_name]))
        self.show_notes(bar_container, notes)
        return bar_container, left_handle, right_handle

    @property
    def supports_css_min_max(self):
        return not runtime.is_standalone_viewer or runtime.QT_VERSION >= 0x050f00

    @property
    def container(self):
        return document.getElementById('book-selection-bar-overlay')

    @property
    def bar(self):
        return self.container.firstChild

    def hide(self):
        self.container.style.display = 'none'

    def show(self):
        sd = get_session_data()
        if not self.view.create_annotation.is_visible and sd.get('show_selection_bar'):
            self.container.style.display = 'block'

    @property
    def is_visible(self):
        return self.container.style.display is not 'none'

    def copy_to_clipboard(self):
        if self.view.currently_showing.selection.text:
            ui_operations.copy_selection(self.view.currently_showing.selection.text)

    def lookup(self):
        if ui_operations.toggle_lookup:
            ui_operations.toggle_lookup(True)
        else:
            self.view.overlay.show_word_actions(self.view.currently_showing.selection.text)

    def internet_search(self):
        text = self.view.currently_showing.selection.text
        if text:
            q = encodeURIComponent(text)
            url = get_session_data().get('net_search_url').format(q=q)
            ui_operations.open_url(url)

    def clear_selection(self):
        self.view.on_handle_shortcut({'name': 'clear_selection'})

    def create_highlight(self):
        self.view.initiate_create_annotation(True)

    def adjust_selection(self):
        self.view.initiate_create_annotation(False)

    def quick_highlight(self):
        cs = self.view.currently_showing.selection
        if cs.text:
            if cs.annot_id:
                self.view.initiate_create_annotation(True)
            else:
                self.view.create_annotation.quick_create()

    def remove_highlight(self):
        annot_id = self.view.currently_showing.selection.annot_id
        if annot_id:
            self.view.create_annotation.remove_highlight(annot_id)

    def show_notes(self, bar, notes):
        notes = (notes or "").strip()
        if not notes:
            return
        notes_container = bar.lastChild
        c = notes_container.lastChild
        notes_container.style.display = notes_container.previousSibling.style.display = 'block'
        c.style.overflow = 'auto'
        if self.supports_css_min_max:
            c.style.maxHeight = 'min(20ex, 40vh)'
        else:
            c.style.maxHeight = '20ex'
        current_block = ''

        def add_para():
            nonlocal current_block
            c.appendChild(E.p(current_block))
            if c.childNodes.length > 1:
                c.lastChild.style.marginTop = '2ex'
            current_block = ''

        for line in notes.splitlines():
            if not line or not line.strip():
                if current_block:
                    add_para()
                    continue
            current_block += line + '\n'
        if current_block:
            add_para()

    def update_position(self):
        container = self.container
        clear(container)
        container.style.overflow = 'hidden'

        cs = self.view.currently_showing.selection
        if not cs or cs.empty or jstype(cs.drag_mouse_position.x) is 'number':
            return self.hide()

        if not cs.start.onscreen and not cs.end.onscreen:
            return self.hide()

        margins = {
            'top': document.getElementById('book-top-margin').offsetHeight,
            'bottom': document.getElementById('book-bottom-margin').offsetHeight,
            'left': document.getElementById('book-left-margin').offsetWidth,
            'right': document.getElementById('book-right-margin').offsetWidth,
        }

        def map_boundary(x):
            return {'x': (x.x or 0) + margins.left, 'y': (x.y or 0) + margins.top, 'height': x.height or 0, 'onscreen': x.onscreen}

        bar, left_handle, right_handle = self.build_bar(cs.annot_id)
        start = map_boundary(cs.start)
        end = map_boundary(cs.end)
        self.show()
        end_after_start = start.y < end.y or (start.y is end.y and start.x < end.x)
        bar_height = bar.offsetHeight
        bar_width = bar.offsetWidth
        buffer = 2
        limits = {
            'top': buffer, 'bottom': container.offsetHeight - bar_height - buffer,
            # - 10 ensures we dont cover scroll bar
            'left': buffer, 'right': container.offsetWidth - bar_width - buffer - 10
        }
        self.position_handles(left_handle, right_handle, start, end, end_after_start)

        def place_vertically(pos, put_below):
            if put_below:
                top = pos
                bar.style.flexDirection = 'column'
            else:
                top = pos - bar_height - buffer
                bar.style.flexDirection = 'column-reverse'
            bar.style.top = top + 'px'
            return top

        # vertical position
        if end_after_start:
            has_space_below = end.y + end.height < container.offsetHeight - bar_height - buffer
            put_below = has_space_below
        else:
            has_space_above = end.y + bar_height - buffer > 0
            put_below = not has_space_above
        top = place_vertically(end.y + end.height if put_below else end.y, put_below)

        # horizontal position
        left = end.x - bar_width // 2
        if cs.drag_mouse_position.x?:
            mouse = map_boundary(cs.drag_mouse_position)
            left = mouse.x - bar_width // 2
        left = max(limits.left, min(left, limits.right))
        bar.style.left = left + 'px'
        lh, rh = left_handle.getBoundingClientRect(), right_handle.getBoundingClientRect()
        changed = position_bar_avoiding_handles(lh, rh, left, top, bar_width, bar_height, container.offsetWidth - 10, container.offsetHeight, buffer)
        if changed:
            if changed.top?:
                place_vertically(changed.top, changed.put_below)
            if changed.left?:
                bar.style.left = changed.left + 'px'


    def position_handles(self, left_handle, right_handle, start, end, end_after_start):

        def place_single_handle(handle, boundary, is_left):
            s = handle.style
            s.display = 'block' if boundary.onscreen else 'none'
            height = boundary.height * 3
            width = boundary.height * 2
            s.width = f'{width}px'
            s.height = f'{height}px'
            bottom = boundary.y + boundary.height
            top = bottom - height
            s.top = f'{top}px'
            if is_left:
                s.left = (boundary.x - width) + 'px'
            else:
                s.left = boundary.x + 'px'

        if not end_after_start:
            start, end = end, start
        place_single_handle(left_handle, start, True)
        place_single_handle(right_handle, end, False)
